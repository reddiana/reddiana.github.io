모델링: 진짜가 아닌데 진짜처럼 느껴지는 것
프로세스: 해야하는 일의 순서를 정의하는 것
![[Pasted image 20240924235028.png]]
## Compoent
Component 정의
- 실행 시점에 발생하는 소프트웨어 요소들
Compoent 예
1. 프로세스
2. 쓰레드
3. 오브젝트 

## Software (intensive) System
요소들이 모여서 하나 이상의 목적을 완전히 달성하는 것

## 기능
기능의 정의
- ==입력값== 대비 ==출력값==의 ==변화==
기능의 특징
- 언어적으로 한마디의 ==동사==로 표현된다.
- 기능이 안되면 시스템의 존재 이유가 사라진다.

## 기능성
기능성의 정의
- ==품질==을 높여주기 위해 추가적으로 도입된 ==기능==들
기능성의 특징
- 언어적으로 한마디의 ==동사==로 표현된다.
- 기능성이 떨어지면 품질이 떨어진다.
> 기능성이 뛰어난 아웃도어 슈즈!!!
> 물은 막고 수증기는 통과!!

## 비기능
비기능(품질)의 정의
- 입력값 대비 출력값의 변화를 ==제약하는 요소들==
비기능의 특징
- 언어적으로 한마디의 ==부사==로 표현된다
- 비기능(품질)이 떨어지면 시장에서 외면받는다.
> 자동차는 사람이나 사물을 ==빠르고 안전하고 편리하게== 이동시켜야 한다.
> Car.move(Thing.position) = Thing.position
> 성능
> 안전성
> 사용(편의)성

> [!NOTE]
> 일반적으로 기능성과 비기능성은 직교(orthogonal)한다
![[Pasted image 20240925000214.png]]

![[Pasted image 20240924234301.png]]

## Non-function (Quality)
![[Pasted image 20240924234412.png]]

## 나누기 원칙(==Orthoronal==)
1. (Biz)Domain vs. (SW) Technical
2. (G)UI vs. Logic vs. Data
3. ...
![[AA__Strategies_나누기.png]]

![[붙이기_Module_View.png]]



## 붙이기
![[AA_붙이기.png]]


## Module View
코딩이 가능할 정도로 디테일하게
그래야 모듈뷰가 끝난것
![[Pasted image 20240924233755.png]]

## Application
![[Pasted image 20240924233828.png]]

Architecture Strategies를 잡을 때 주의할 점
1. 아키텍처 전략을 결정하는 ==합리적==(reasoning) 방법이 있어야 한다.
  - 반드시 여러개(2 or 3개)의 후보 전략이 있어야 한다.
  - 후보 전략 간의 장단점을 비교(표)하여 선택한다.
2. Open Source 결정하는 ==합리적== 기준이 있어야 한다.
  - Version이 높은가?
  - Release 주기가 일정한가?
  - 다운로드 횟수가 많은가?

![[Pasted image 20240924234020.png]]

![[Pasted image 20240924235305.png]]

## Runtime View 
그리는 방법
1. 최상위 수준의 Runtime View를 그린다.
  - 참조 아키텍처를 우선 작성한다. (모든 Actor가 다 나와야 함)
  - 가장 중요한 ==전략이 보이는== 설계를 추가한다.
  - 될 수 있는한 많은 정보를 담아야 한다 (범례 꼭 추가)
  - 복잡하면 안된다. (컴포넌트가 15~20개 정도)
2. 2nd level runtime view 작성 방법
  - 최상위 수준에서 연결되는 요소를 카피한다.
  - 최상위 수준의 요소와 연결되는 내부 컴포넌트를 찾는다.
  - 요소가 10개 수준에서 많은 정보를 담아낼 수 있도록 한다.

![[Pasted image 20240924234116.png]]

QAS(Quality Attribute Scenario) 3원칙
1. 특정한 상황을 가정하라.
2. 수치로 작성하라.
3. 순서를 정하라.
![[Pasted image 20240924235408.png]]

